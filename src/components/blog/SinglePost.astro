---
import { Image } from 'astro:assets';
import { getFormattedDate } from '~/utils/utils';
import type { Post } from '~/types';
import PostIndex from './PostIndex.astro';

export interface Props {
  post: Post;
  url: string | URL;
}

const { post } = Astro.props;
const { Content } = post;
function darkenColor(color, amount) {
  let [r, g, b, a] = color.match(/\d+/g).map(Number);
  r = Math.floor(r * amount);
  g = Math.floor(g * amount);
  b = Math.floor(b * amount);
  return `rgba(${r}, ${g}, ${b}, ${a - 0.25})`;
}

const adjustedColor1 = darkenColor(post.accentColor, 0.5);
---

<style>
  .bg-accentColor {
    background: radial-gradient(
      95% 100% at 50% 0%,
      var(--gradient-base-color) 0%,
      var(--adjusted-color1) 50%,
      transparent 100%
    );
    opacity: 0;
    animation: fadeInOut 0.75s cubic-bezier(0.26, 1, 0.48, 1) forwards 0.75s;
  }
  .postHeaderFont {
    background-image: linear-gradient(to bottom, #fff 50%, transparent);
    text-shadow: 0 5px 15px var(--gradient-base-color) 0%, 0 -5px 15px rgba(255, 90, 0, 0.15),
      0 -5px 25px rgba(255, 255, 255, 0.25);
    -webkit-text-fill-color: transparent;
    -webkit-background-clip: text;
    background-clip: text;
  }
  @keyframes fadeInOut {
    0% {
      opacity: 0;
    }
    100% {
      opacity: 1;
    }
  }
</style>

<section class="w-full h-full">
  <div
    class="bg-accentColor absolute w-full h-full"
    style={{
      '--gradient-base-color': post.accentColor,
      '--adjusted-color1': adjustedColor1,
    }}
  >
  </div>
  <PostIndex postIndex={post.postIndex} />
  <article class="opacity-0 blur-lg max-w-[80vw] lg:max-w-3xl xl:max-w-4xl 2xl:max-w-5xl 3xl:max-w-6xl mx-auto">
    <header class="w-full h-full pt-28">
      <div class="flex justify-between flex-col pb-16 mt-0 mb-2 px-4 sm:px-6 sm:items-center">
        <h1
          class="postHeaderFont px-4 text-[80px] mx-auto font-medium tracking-tighter leading-snug animate-on-scroll"
          data-type="simple"
          data-delay="0"
          data-duration="2.5"
          data-easing="Expo.easeOut"
          style={{
            '--gradient-base-color': post.accentColor,
            '--adjusted-color1': adjustedColor1,
          }}
        >
          {post.title}
        </h1>
        <p class="animate-on-scroll" data-type="simple" data-delay="0" data-duration="2.5" data-easing="Expo.easeOut">
          <time class="opacity-50 text-white" datetime={String(post.publishDate)}
            >{getFormattedDate(post.publishDate)}</time
          >
        </p>
      </div>
      {
        post.image ? (
          <>
            <Image
              class="rounded-3xl"
              alt={`Imagen del ${post.title}`}
              widths={[275, 475, 575, 1050, 1250]}
              sizes={`(max-width: 550px) 275px, (max-width: 750px) 475px, (max-width: 950px) 575px,(max-width: 1920px) 1050px, (max-width: 2560px) 1250px,`}
              quality={'mid'}
              format="avif"
              loading="lazy"
              src={post.image}
              decoding="async"
            />
          </>
        ) : (
          <div class=" mx-auto px-4 sm:px-6">
            <div class="border-t dark:border-slate-700" />
          </div>
        )
      }
    </header>

    <div class="mx-auto">
      <Content />
    </div>
  </article>
</section>
<script>
  // eslint-disable-next-line no-unused-vars
  import { YouTube } from '@astro-community/astro-embed-youtube';
  import { gsap } from 'gsap';
  const article = document.querySelector('article');

  gsap.to(article, {
    duration: 1,

    filter: 'blur(0px)',
    opacity: 1,
    ease: 'power3.out',
  });

  /*countup*/

  const animateCounters = () => {
    const counters = document.querySelectorAll('.counter');
    counters.forEach((counter) => {
      const finalNumber = parseInt(counter.textContent || '0');
      gsap.fromTo(
        counter,
        { innerHTML: 0 },
        {
          innerHTML: finalNumber,
          duration: 3,
          ease: 'Expo.easeOut',
          snap: { innerHTML: 1 },

          onUpdate: function () {
            const target = this.targets()[0];
            if (target.innerHTML) {
              counter.textContent = Math.ceil(Number(target.innerHTML)).toString();
            }
          },
        }
      );
    });
  };

  document.addEventListener('DOMContentLoaded', animateCounters);

  //BENTO//
  interface ExtendedHTMLElement extends HTMLElement {
    style: CSSStyleDeclaration & {
      '--mouse-x': string;
      '--mouse-y': string;
    };
    mouseX?: number;
    mouseY?: number;
  }

  document.getElementById('cards')!.onmousemove = (e: MouseEvent) => {
    const cards = document.getElementsByClassName('bento');

    for (const card of Array.from(cards) as ExtendedHTMLElement[]) {
      const rect = card.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (card.mouseX === undefined) card.mouseX = x;
      if (card.mouseY === undefined) card.mouseY = y;

      card.mouseX = x;
      card.mouseY = y;
    }
  };

  function lerp(start: number, end: number, factor: number) {
    return (1 - factor) * start + factor * end;
  }

  function animate() {
    const cards = document.getElementsByClassName('bento');

    for (const card of Array.from(cards) as ExtendedHTMLElement[]) {
      if (card.mouseX !== undefined && card.mouseY !== undefined) {
        // Interpolación lineal para suavizar el movimiento
        const x = lerp(parseFloat(card.style.getPropertyValue('--mouse-x') || '0'), card.mouseX, 0.1);
        const y = lerp(parseFloat(card.style.getPropertyValue('--mouse-y') || '0'), card.mouseY, 0.1);

        card.style.setProperty('--mouse-x', `${x}px`);
        card.style.setProperty('--mouse-y', `${y}px`);
      }
    }

    requestAnimationFrame(animate);
  }
  animate();

  const nextSection = document.getElementById('nextSection');
  nextSection?.addEventListener('mouseenter', () => {
    const image = document.getElementById('image');
    gsap.to(image, {
      y: '-20vh',
      duration: 1.5,
      ease: 'Expo.easeOut',
    });
  });
  nextSection?.addEventListener('mouseleave', () => {
    const image = document.getElementById('image');
    gsap.to(image, {
      y: '0',
      duration: 1.5,
      ease: 'Expo.easeOut',
    });
  });
  const canvasContainer: HTMLElement = document.getElementById('canvas-container')!;
  const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;
  const ctx: CanvasRenderingContext2D = canvas.getContext('2d')!;

  // Ajustar el tamaño del canvas al tamaño del contenedor
  function resizeCanvas() {
    canvas.width = canvasContainer.clientWidth;
    canvas.height = canvasContainer.clientHeight;
  }

  // Llamar a resizeCanvas en la carga inicial y en el evento de redimensionamiento
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  interface Star {
    x: number;
    y: number;
    radius: number;
    velocity: number;
    alpha: number; // Opacidad de la estrella
  }

  const stars: Star[] = [];
  const maxStars: number = 100; // Cantidad de estrellas

  // Función para crear una nueva estrella
  function createStar(): Star {
    return {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height + canvas.height,
      radius: Math.random() * 1.25 + 0.5, // Tamaño de las estrellas
      velocity: Math.random() * 0.2 + 0.1, // Velocidad de la estrella
      alpha: 1, // Opacidad inicial
    };
  }

  // Crear estrellas iniciales
  for (let i = 0; i < maxStars; i++) {
    stars.push(createStar());
  }

  let animating = false;

  // Función para reiniciar las estrellas
  function resetStars() {
    stars.forEach((star) => {
      star.y = Math.random() * canvas.height + canvas.height; // Coloca las estrellas en la parte inferior
      star.alpha = 1; // Restablece la opacidad
    });
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  // Evento mouseenter
  nextSection?.addEventListener('mouseenter', () => {
    animating = true;
    starAnimation();
  });

  // Evento mouseout
  nextSection?.addEventListener('mouseout', () => {
    resetStars();
    animating = false;
  });

  // Función de animación
  function starAnimation() {
    if (!animating) return; // Detener animación si animating es falso

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    stars.forEach((star) => {
      star.y -= star.velocity; // Mover la estrella hacia arriba
      if (star.y < -star.radius) {
        star.y = canvas.height + star.radius; // Reiniciar la posición de la estrella
        star.alpha = 1; // Restablecer la opacidad
      }

      // Reducir la opacidad de forma aleatoria a medida que se acercan al borde superior
      if (star.y < canvas.height * 0.2) {
        star.alpha = Math.random() * (star.y / (canvas.height * 0.2));
      }

      // Dibujar la estrella
      ctx.globalAlpha = star.alpha; // La opacidad de la estrella
      ctx.fillStyle = '#fff'; // Color blanco
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
      ctx.fill();
    });

    requestAnimationFrame(starAnimation);
  }
</script>
